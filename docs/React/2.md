# 3:React 性能优化

要想了解 `React` 都可以进行哪些性能的优化之前我们必须要先掌握 `React` 的渲染和更新机制是如何的

## React 渲染和更新机制

在[1:JSX 的本质-总结](./#总结)中我们已经了解了 React 是如何从编写 JSX 代码到渲染的,那么 React 的更新流程是什么样的呢?<br/>
我们可以结合 React 官网给出的生命周期图来参考一下<br/>
![xxx](../images/React/2/0.png)<br/>
不难看出在 `Updating` 模块中只要 `props` 和 `state` 发生改变就会触发 `render` 函数, 在 `render` 函数中 `React` 会把新创建出来的 `虚拟DOM` 和 之前的 `DOM` 进行对比并计算出最后要转换成的 `DOM对象树`,最终转化成 `真实DOM` 并渲染到页面上<br/>
但对比两个树并不是一件容易的事, React 官网中也提到了:
::: tip
即使在最前沿的算法中，该算法的复杂程度为 O(n^3)，其中 n 是树中元素的数量。
:::
而 React 在两棵树的对比上提出了一套复杂度为 O(n) 的算法--->Diffing

## Diffing

关于 React 的 Diffing 算法, React 官网也给出了相应的讲解,在这里可以总结为以下几点

### 1:比较根节点

**对比两棵树同一级元素的根节点,根节点不同,直接删掉重建,不再深度比较**
举个栗子

```js
// 旧的虚拟DOM树
<div>
  <Counter />
</div>
// 新的虚拟DOM树
<span>
  <Counter />
</span>
```

当判断到上面的根节点 `<div></div>` 和 `<span></span>` 时,因为根节点不相同, 所以直接删除旧树重建新树<br/>
**对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。**

```js
<div className="before" title="stuff" />
<div className="after" title="stuff" />
```

通过对比这两个元素，`React` 知道只需要修改 `DOM` 元素上的 `className` 属性。<br/>
当更新 style 属性时，React 仅更新有所更变的属性。比如:

```js
<div style={{color: 'red', fontWeight: 'bold'}} />
<div style={{color: 'green', fontWeight: 'bold'}} />
```

通过对比这两个元素，`React`知道只需要修改 `DOM` 元素上的 `color` 样式，无需修改 `fontWeight。`

### 2:递归比较子节点

比较完根节点之后, React 就会递归的比较子节点,也就是下面的代码

```js
<ul>
  <li>first</li>
  <li>second</li>
</ul>
```

改变为

```js
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

React 会按照顺序递归的比较 `<li>first</li>` 与 `<li>first</li>`, `<li>second</li>` 与 `<li>second</li>`最后发现只新增了一个 `<li>third</li>`,所以最后会保留`<li>first</li>`和`<li>second</li>`, 插入新增的`<li>third</li>`树,这样性能上不会有很大的损耗,如果你将`<li>third</li>`插入到表头的话:

```js
<ul>
  <li>first</li>
  <li>second</li>
</ul>
```

改变为

```js
<ul>
  <li>third</li>
  <li>first</li>
  <li>second</li>
</ul>
```

React 依旧会默认的对子节点进行递归的比较, 也就是 `<li>first</li>` 与 `<li>third</li>` `<li>second</li>`与 `<li>first</li>`因为两个节点的子元素并不相同,所以会重建每一个子元素, 这样会产生性能上的问题,所以接下来 [性能优化-Keys](#性能优化-keys) 就登场了

## 性能优化-keys

为了解决上面的问题, `React` 推荐我们使用 `key` 属性, 当一个元素有 `key` 属性之后, `React` 会使用 `key` 来匹配原树和新树的子元素, 如下代码

```js
<ul>
  <li key="1">first</li>
  <li key="2">second</li>
</ul>
```

转换为

```js
<ul>
  <li key="3">third</li>
  <li key="1">first</li>
  <li key="2">second</li>
</ul>
```

因为 React 会根据 key 进行匹配然后进行比较,发现只有`<li key="3">third</li>`是新元素,所以只是插入一下新元素然后改变一下
`<li key="1">first</li>` 和 `<li key="2">second</li>`的位置即可,这样在性能上就有了很大的提升<br/>
**key 的注意事项**
:::tip
key 应该是唯一的<br/>
key 不要使用随机数（随机数在下一次 render 时，会重新生成一个数字)<br/>
使用 index 作为 key，对性能是没有优化的<br/>
:::

## 性能优化-shouldComponentUpdate

在使用 shouldComponentUpdate 之前我们先看一下下面的代码

```js
import React, { Component } from "react";
// Header
function Header() {
  console.log("Header render函数被调用");
  return <h2>我是Header组件</h2>;
}
// Main
class Main extends Component {
  render() {
    console.log("Main render函数被调用");
    return (
      <div>
        <Banner />
        <ProductList />
      </div>
    );
  }
}
// Footer
function Footer() {
  console.log("Footer render函数被调用");
  return <h2>我是Footer组件</h2>;
}

export default class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0,
    };
  }
  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>
        <Header />
        <Main />
        <Footer />
      </div>
    );
  }
  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
}
```

代码结构很清晰,如图<br/>
<br/>
![xxx](../images/React/2/1.svg)<br/>
当 App 第一次加载时，浏览器会打印出

```js
App render函数被调用
Header被调用
Main render函数被调用
Footer render函数被调用
```

上面的结果应该是我们预期的结果,第一次打开页面时,加载 App 组件以及子组件<br/>
接下来我们点击 `<butoon>+1</button>`按钮后,浏览器依旧会打印出

```js
App render函数被调用
Header render函数被调用
Main render函数被调用
Footer render函数被调用
```

我们可以走一下流程, 点击`<butoon>+1</button>`后, App 组件内 state 发生改变所以会打印出 `App render函数被调用`,随后 `Header` `Main` `Banner` 组件也重新加载了,这是因为 `React` 内部**默认**(这个默认下面会讲到)情况下当父组件重新渲染时子组件也跟着一起重新渲染<br/>
这时候就引起了我们的思考,我们只是改变了 App 组件中的 state 而所有子组件也一起重新渲染了,这样来做浪费了很多的性能,那么有什么办法呢?<br/>
我们可以再看一下 React 官方比较详细的生命周期函数, 如图:<br/>
![xxx](../images/React/2/2.png)<br/>
可以看出在 Updating 模块中多出了 `shouldComponentUpadateUpdate` 生命周期函数,这个函数在 `render` 函数之前,也就是所我们可以根据 `shouldComponentUpadateUpdate`的返回值来决定是否执行 `render` 函数,我们来看一下下面的代码:

```js
import React, { Component } from "react";

export default class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0,
    };
  }
  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>
      </div>
    );
  }

  shouldComponentUpdate(nextProps, nextState) {
    return false;
  }
  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
}
```

我们点击按钮,结果计数并没有增加,控制台也没打印出 `App render函数被调用`,可以看出 `render` 函数已经被阻断了,有了这个函数就可以在组件的 `render` 函数调用前判断是否调用 `render` 函数来确定是否重新渲染组件了,如下例子

```js
import React, { Component } from "react";
export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
      message: "Hello World",
    };
  }
  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={(e) => this.increment()}>+1</button>
        <button onClick={(e) => this.changeText()}>改变文本</button>
      </div>
    );
  }
  increment() {
    this.setState({
      counter: this.state.counter + 1,
    });
  }
  changeText() {
    this.setState({
      message: "Hello React",
    });
  }
}
```

`App` 组件中 `state` 有 `counter` 和 `message`但此组件并不依赖于 `message`<br/>我们有以下需求:改变 `message` 不重新渲染组件,只有改变 `counter` 的时候才重新渲染组件<br/>
可以在 App 中增加 以下代码

```js
 shouldComponentUpdate(nextProps, nextState) {
    //nextProps为新的props, nextState为新的state
    if (this.state.counter !== nextState.counter) {
      return true;
    }
    return false;
  }
```
这样我们点击改变文本组件就不会重新渲染了<br/>
那么 `shouldComponentUpadate` 为什么就会决定组件的更新与否呢? 我们可以看一下 `React` 的源码来进一步了解<br/>
在源码的 `ReactFiberClassComponent.js`文件中 `checkShouldComponentUpdate`函数判断组件更新与否,如下:
```js
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext,
) {
  const instance = workInProgress.stateNode;
  if (typeof instance.shouldComponentUpdate === 'function') {
    const shouldUpdate = instance.shouldComponentUpdate(
      newProps,
      newState,
      nextContext,
    );
    return shouldUpdate;
  }
  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return (
      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
    );
  }
  return true;
}
```
这个函数默认返回 `true`,也就是前面的默认情况下父组件更新子组件重新渲染的情况,如果该组件中存在 `shouldComponentUpdate`则返回值为 `shouldComponentUpdate` 的返回值<br/>
有了 `shouldComponentUpadate` 的基础我们就可以理解 React 的**不可变数据力量**了<br/>
在[2:setState](./1.html#不可变值-函数式编程-纯函数)中我们提到过**不可变数据的力量**我们接着用那个案例
```js
export default class APP extends Component {
    constructor(props) {
        super(props)
        this.state = {
            list: ['🍎apple', '🍌banana', '🍅tomato']
        }
    }
    render() {
        return (
            <div style={{margin: '200px auto', width: '200px'}}>
                {this.state.list.map((item) => {
                    return (
                        <h1 key={item}>{item}</h1>
                    )
                })}
                <button onClick={e => {this.addPotato()}}>＋🥔</button>
            </div>
        );
    }
    addPotato() {
        this.state.list.push('🥔potato')
        this.setState({
            list: this.state.list
        })
    }
}
```
点击按钮可以实现对列表数据的增加,但是想用 shouldComponent 来重构以下代码来实现一些组件的不必要渲染,如下
```js
export default class APP extends Component {
    constructor(props) {
        super(props)
        this.state = {
            list: ['🍎apple', '🍌banana', '🍅tomato']
        }
    }
    render() {
        return (
            <div style={{margin: '200px auto', width: '200px'}}>
                {this.state.list.map((item) => {
                    return (
                        <h1 key={item}>{item}</h1>
                    )
                })}
                <button onClick={e => {this.addPotato()}}>＋🥔</button>
            </div>
        );
    }
    shouldComponentUpdate(nextProps, nextState) {
        if (this.state.list !== nextState.list) {
          return true;
        }
        return false;
    }
    addPotato() {
        this.state.list.push('🥔potato')
        this.setState({
            list: this.state.list
        })
    }
}
```
执行上述代码,点击按钮,发现列表并没有重新刷新,这是因为在 `setState` 前对 `list` 数据进行直接的修改,而在 `setState` 中
`list` 和 `this.state.list` 用的是同一个引用所以在 `shouldComponentUpadate` 返回 `false` 组件不会重新渲染,模拟内存结构如下:<br/></br></br>
![xxx](../images/React/2/3.svg)<br/>
修改 `addPotato(){}` 代码后
```js
    addPotato() {
        const newList = this.state.list.concat('🥔potato')
        this.setState({
            list: newList
        })
    }
```
模拟内存结构如下<br/><br/><br/>
![xxx](../images/React/2/4.svg)<br/>

## 性能优化-PureComponent 和 memo
熟悉了 `shouldComponentUpadateUpdate` 之后,考虑到性能的优化我们肯定会优先考虑在组件中使用它,但存在以下几点问题:<br/>
- 如果每个组件都写一个 `shouldComponentUpadateUpdate`会出现非常多的重复代码
- 函数式组件并没有生命周期<br/>
为了解决以上问题 `PureComponent` `memo` 就可以宣布登场了
**PureComponent**<br/>
类组件只要继承 `PureComponent` 默认在发生 `Updating` 时就会对内部数据进行比较判断是否重新渲染(相当于 `shouldComponentUpdate`)<br/>代码如下:
```js
import React, { PureComponent } from 'react';
// Header
function Header() {
  console.log("Header render函数被调用");
  return <h2>我是Header组件</h2>
}
// Main
class Main extends PureComponent {
  render() {
    console.log("Main render函数被调用");
    return (
      <div>
        <Banner/>
        <ProductList/>
      </div>
    )
  }
}
// Footer
function Footer() {
  console.log("Footer render函数被调用");
  return <h2>我是Footer组件</h2>
}
export default class App extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0
    }
  }
  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <Header/>
        <Main/>
        <Footer/>
      </div>
    )
  }
  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}
```
这次可以发现点击 +1按钮后只会打印出
```js
App render函数被调用
Header render函数被调用
Footer render函数被调用
```
因为 `Main` 组件内部数据发生**浅层次比较**后没有数据发生变化从而不重新渲染<br/>
为什么是浅层次比较? 那么就要阅读一下 `PureComponent` 的源码了<br/>
首先 `PureComponent`源码:
```js {9, 12}
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  // If a component has string refs, we will assign a different object later.
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
Object.assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;
export {Component, PureComponent};
```
`checkShouldComponentUpdate` 源码:
```js
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext,
) {
  // 在 PureComponent中声明了pureComponentPrototype.isPureReactComponent = true;
  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return (
      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
    );
  }
  return true;
}
```
`shallowEqual` 源码:
```js
function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) {
    return true;
  }

  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  for (let i = 0; i < keysA.length; i++) {
    if (
      !hasOwnProperty.call(objB, keysA[i]) ||
      !is(objA[keysA[i]], objB[keysA[i]])
    ) {
      return false;
    }
  }
  return true;
}
export default shallowEqual;
```
结合三部分源码可以看出如果组件继承 pureComponnet 后,在检查是否更新的时候会对组建的数据进行浅层次比较判断是否刷新组件

**memo**<br/>
类组件的更新方案我们可以通过 pureComponnet 来解决了,函数式组件我们可以使用 memo 进行一层包裹,如下代码
```js
import React, { PureComponent, memo } from 'react';

// Header
const MemoHeader = memo(function Header() {
  console.log("Header被调用");
  return <h2>我是Header组件</h2>
})
// Main
class Main extends PureComponent {
  render() {
    console.log("Main render函数被调用");
    return (
      <div>
        <Banner/>
        <MemoProductList/>
      </div>
    )
  }
}
// Footer
const MemoFooter = memo(function Footer() {
  console.log("Footer被调用");
  return <h2>我是Footer组件</h2>
})

export default class App extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0
    }
  }
  render() {
    console.log("App render函数被调用");
    return (
      <div>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <MemoHeader/>
        <Main/>
        <MemoFooter/>
      </div>
    )
  }
  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}
```
点击按钮 +1 时控制台中只输出了 App render函数被调用

## 性能优化-immutableJS

## 性能优化-Hooks:useEffect

## 性能优化-Hooks:useCallback

## 性能优化-Hooks:useMemo
