# 4:this
## 七种情况下的this指向
**普通函数**<br>
- 普通函数被调用`this`指向window
``` javaScript
    // 普通函数
    function fn(){
        console.log(this);   /* window */         
    }
    window.fn() /* 相当于window.fn */
```
**绑定事件**<br>
- 绑定事件`this`指向绑定事件对象
``` javaScript
    <button>click</button>
    <script>
       var btn = document.querySelector('button')
       btn.onclick = function(){
           console.log(this);    /* <button>click</button> */       
       }
    </script>
```
**定时器**<br>
定时器`this`指向`Window`
``` javaScript
    setInterval(function(){
        console.log(this);    /* Window */      
    },2000)    
```
**立即执行函数**<br>
立即执行函数`this`指向`Window`
``` javaScript
    (function(){
        console.log(this); /* Window */            
    })()
```
**作为对象方法被调用**<br>
作为对象方法被调用`this`指向该方法所属对象
``` javaScript
    const obj = {
        name:'Andy',
        say(){
            console.log(this);   /*obj*/             
        }
    }
    obj.say()
```
**在class方法中被调用**<br>
class方法中被调用`this`指向调用方法的对象
``` javaScript
    class People {
        constructor(name) {
            this.name = name   /* Andy对象 */
        }
        say() {
            console.log(this); /* Andy对象 */
        }
    }
    const Andy = new People('Andy')
    Andy.say()
```
**箭头函数**<br>
ES6箭头函数中`this`默认指向定义它时，所处上下文的对象的`this`指向。即ES6箭头函数里`this`的指向就是上下文里对象`this`指向，偶尔没有上下文对象，`this`就指向`window`
``` javaScript
const obj = {
  radius: 10,  
  diameter() {    
      return this.radius * 2
  },  
  perimeter: () => 2 * Math.PI * this.radius
}
console.log(obj.diameter())    // 20
console.log(obj.perimeter())    // NaN
/*  this应该指向上下文函数this的指向，这里上下文没有函数对象，
就默认为window，而window里面没有radius这个属性，就返回为NaN。*/
```
:::warning
即使是call，apply，bind等方法也不能改变箭头函数this的指向
:::

## 使用call, apply, bind改变函数内部`this`指向
**call**<br>
1. 调用函数<br>
2. 改变函数的this指向<br>
3. `call`基本应用在构造函数的继承上<br>
```javaScript
var o = {
	name: 'andy'
}
function fn(a, b) {
      console.log(this);
      console.log(a+b)
};
fn(1,2)// 此时的this指向的是window 运行结果为3
fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3
```

**apply**<br>
1. 调用函数(传递参数必须是数组(伪数组))<br>
2. 改变函数的this指向<br>
3. `apply`主要应用 比如说我们可以借助数学对象`Math`求数组中数字的最大值<br>
``` javaScript
    var arr = [1,2,3,4,5]
    var result = Math.max.apply(Math,arr);
    console.log(result);/* 5 */
```

**bind**<br>
1. bind()方法不会调用函数
2. 改变函数的this指向
3. 返回一个改变原函数this指向的新函数
4. 如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind
5. 应用场景,假如我们有一组按钮`<button>`点击完每个按钮每个按钮会被禁用,然后过两秒后会恢复正常,或许你会这样写
``` JavaScript
<button>btn1</button>
<button>btn2</button>
<button>btn3</button>
<script>
    var btns = document.querySelectorAll('button');
    for(let i = 0; i < btns.length; i++){
        btns[i].onclick = function(){
            this.disabled = true
            setTimeout(function(){
                this.disabled = false /* 这里的 this 指向 Windows所以不能恢复正常 */
            },2000)
        }
    }
</script>    
```
这样写之后按钮并不会恢复正常,因为定时器里面的`this` 指向 `Windows`,这时我们就要考虑使用bind了  
``` JavaScript
<button>btn1</button>
<button>btn2</button>
<button>btn3</button>
<script>
    var btns = document.querySelectorAll('button');
    for(let i = 0; i < btns.length; i++){
        btns[i].onclick = function(){
            this.disabled = true
            setTimeout(function(){
                this.disabled = false /* 这里的 this 指向当前我们点击的btn,就能达到我们预期的结果了*/
            }.bind(this),2000)
        }
    }
</script>    
```
::: tip
以上文档如有错误请联系我进行改进
:::